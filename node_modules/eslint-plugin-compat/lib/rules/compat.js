(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module', 'exports', 'babel-runtime/core-js/set', '../Lint'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('babel-runtime/core-js/set'), require('../Lint'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.set, global.Lint);
    global.compat = mod.exports;
  }
})(this, function (module, exports, _set, _Lint2) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _set2 = _interopRequireDefault(_set);

  var _Lint3 = _interopRequireDefault(_Lint2);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  exports.default = {
    meta: {
      docs: {
        description: 'Ensure cross-browser API compatibility',
        category: 'Compatibility',
        recommended: true
      },
      fixable: 'code',
      schema: []
    },
    create: function create(context) {
      // FIXME: lint() creates a new Set on every invocation. Fix this by removing
      //        creating a single set and passing a refrence lint() a reference
      //        to it
      //
      // FIXME: Another performance enhancement includes collecting all the rules
      //        into a single list. As of now, every call to lint() must find
      //        all the corresponding AST node rules.
      function lint(node) {
        var _Lint = (0, _Lint3.default)(node, context.settings.targets, context.settings.polyfills ? new _set2.default(context.settings.polyfills) : undefined),
            isValid = _Lint.isValid,
            rule = _Lint.rule,
            unsupportedTargets = _Lint.unsupportedTargets;

        if (!isValid) {
          context.report({
            node: node,
            message: [(0, _Lint2.generateErrorName)(rule), 'is not supported in latest', // HACK: 'latest' is hardcoded. should
            unsupportedTargets.join(', ') //       be resolved dynamically using
            ].join(' ') //       eslintrc config
          });
        }
      }

      return {
        // HACK: Ideally, rules will be generated at runtime. Each rule will have
        //       have the ability to register itself to run on specific AST
        //       nodes. For now, we're using the `CallExpression` node since
        //       its what most rules will run on
        CallExpression: lint,
        MemberExpression: lint,
        NewExpression: lint
      };
    }
  };
  module.exports = exports['default'];
});